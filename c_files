#define _CRT_SECURE_NO_WARNINGS
#include<easyx.h>
#include<conio.h>
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include <windows.h>
#include<mmsyscom.h>
#pragma comment(lib, "Msimg32.lib")
#pragma comment(lib, "winmm.lib")
// 假设目标帧率为 60 FPS
#define TARGET_FPS 60
#define FRAME_DELAY (1000 / TARGET_FPS)
#define enemy_num 5
#define buffet_num 5
int score = 0;
int count = 3;
int Timer(int ms, int id) {
    static int start[5];
    int end = clock();
    if (end - start[id] >= ms) {
        start[id] = end;
        return 1;
    }
    return 0;
}
 
struct myplane {
    int x ;
    int y ;
    int live;
}; 
myplane p1;
myplane p2[enemy_num];
struct buff {
    
    int x;
    int y;
    int live;
};
IMAGE img;
IMAGE bk;
IMAGE buffet;
IMAGE bk1;
IMAGE img1;
IMAGE img2;
IMAGE gameOverImg;
buff Buff[buffet_num];
void load() {
    loadimage(&img1, "D:\\vsexamine\\Project1\\敌机.png", 69, 91);
    loadimage(&bk, "D:\\vsexamine\\Project1\\背景.png", 500, 690);
    loadimage(&img, "D:\\vsexamine\\Project1\\图层 1.png", 69, 91);
    loadimage(&buffet, "D:\\vsexamine\\Project1\\图层 4.png", 16, 38);
    loadimage(&img2, "../爆炸特效.png", 69, 91);
    gameOverImg.Resize(400, 200);
    SetWorkingImage(&gameOverImg);
    setbkcolor(BLACK);
    cleardevice();
    settextcolor(WHITE);
    settextstyle(40, 0, _T("宋体"));
    outtextxy(50, 50, _T("游戏结束"));
    settextstyle(20, 0, _T("宋体"));
    outtextxy(120, 120, _T("按R键重新开始"));
    SetWorkingImage(NULL);
}
void create_buffet() {

    for (int i=0;i <buffet_num;i++) {
        if (!Buff[i].live) {
            Buff[i].x = p1.x + 29;
            Buff[i].y = p1.y;
            Buff[i].live = 1;
            //PlaySound("../laser5.wav", NULL, SND_FILENAME | SND_ASYNC | SND_NOWAIT);
            break;
        }
        
    }
}
void create_enemyplane() {

    for (int i = 0;i < enemy_num;i++) {
        if (!p2[i].live && Timer(500, 2)) {
            p2[i].x = rand() % 400;
            p2[i].y = -10;
            p2[i].live = 1;
            break;
        }

    }
}
void showGameOver();
void Score();
void gameshow() {
    BeginBatchDraw();
    putimage(0, 0, &bk);
  /*  putimage(p2.x, p2.y, &img1);*/
    COLORREF transparentColor = RGB(0, 0, 0);
    COLORREF transparentColor1 = RGB(255, 255, 255);
    TransparentBlt(GetImageHDC(), p1.x, p1.y, 69, 91, GetImageHDC(&img), 0, 0, 69, 91, transparentColor);
    /*TransparentBlt(GetImageHDC(), p1.x, p1.y, 69, 91, GetImageHDC(&img2), 0, 0, 69, 91, transparentColor1);*/
    for (int j = 0;j < enemy_num;j++) {
        if (p2[j].live) {
            TransparentBlt(GetImageHDC(), p2[j].x, p2[j].y, 69, 91, GetImageHDC(&img1), 0, 0, 69, 91, transparentColor);
        }
    }
    for (int i = 0;i < buffet_num;i++){
    if (Buff[i].live) {
        //putimage(Buff[i].x, Buff[i].y, &buffet);
        TransparentBlt(GetImageHDC(), Buff[i].x, Buff[i].y, 16, 38, GetImageHDC(&buffet), 0, 0, 16, 38, transparentColor);
              
    }
    }Score();
    if (p1.live == 0) {
        showGameOver();
        if (_kbhit()) {
            if (_getch()=='r') {
                p1.live=1;
                for (int i = 0;i < enemy_num;i++) {
                    p2[i].live = 0;
                    score = 0;
                    count = 3;
                }
            }
        }
    }
    EndBatchDraw();
    
} 

void buffet_move() {
    for (int i = 0;i < buffet_num;i++) {
        if (Buff[i].live) {
            Buff[i].y -=25 ;
        }
        if (Buff[i].y < 0) {
            Buff[i].live = 0;
        }
    }
}
void enemyplane_move() {
    for (int i = 0;i < enemy_num;i++) {
        if (p2[i].live) {
            p2[i].y +=8;
            if (score >=100) {
                p2[i].y += 9;
            }
            if (score == 200) {
                p2[i].y += 10;
            }
        }
        if (p2[i].y > 690) {
            p2[i].live = 0;
        }
    }
}

void plane_move() {
    if(Timer(100, 0)){
    if (GetAsyncKeyState('W') & 0x8000) {
        p1.y -= 27;
        if (p1.y < 0) p1.y = 0;  // 边界检查
    }
    if (GetAsyncKeyState('S') & 0x8000) {
        p1.y += 27;
        if (p1.y > 690 - 91) p1.y = 690 - 91;  // 边界检查
    }
    if (GetAsyncKeyState('A') & 0x8000) {
        p1.x -= 27;
        if (p1.x < 0) p1.x = 0;  // 边界检查
    }
    if (GetAsyncKeyState('D') & 0x8000) {
        p1.x += 27;
        if (p1.x > 500 - 69) p1.x = 500 - 69;  // 边界检查
    }}
    if (GetAsyncKeyState('J') & 0x8000 && Timer(200, 1)) {
        create_buffet(); 
    }
    
}


//void move() {
//    switch (_getch()) {
//    case 'w':p1.y -= 10;break;
//    case 's':p1.y += 10;break;
//    case 'a':p1.x -= 10;break;
//    case 'd':p1.x += 10;break;
//    case 'j':create_buffet();break;
//    }
//    }
void pengzhuang();

int main() {
    srand((unsigned int)time(NULL));
    p1.x = 250 - 34;
    p1.y = 600;
    p1.live = 1;
    load();
    initgraph(500, 690);
    // 在 main() 中替换 PlaySound 背景音乐部分
    MCIERROR err;
    err = mciSendString("open \"D:\\vsexamine\\Project1\\Powerful-Trap-(chosic.com).mp3\" type mpegvideo alias bgm", NULL, 0, NULL);
    if (err != 0) {
        char errMsg[256];
        mciGetErrorString(err, errMsg, sizeof(errMsg));
        MessageBox(NULL, errMsg, "MCI 错误", MB_OK);
    }
    else {
        mciSendString("play bgm repeat", NULL, 0, NULL);
    }

    while (1) {
        DWORD frameStartTime = GetTickCount();
         gameshow();
         if (p1.live) {
             pengzhuang();
             buffet_move();
             /*move();*/
             plane_move();
             create_enemyplane();
             enemyplane_move();
         }
         
         DWORD frameEndTime = GetTickCount();
         DWORD frameTime = frameEndTime - frameStartTime;

         if (frameTime < FRAME_DELAY) {
             Sleep(FRAME_DELAY - frameTime);
         }
    }
    system("pause");
}
void pengzhuang() {
    COLORREF transparentColor = RGB(0, 0, 0);
    for (int i = 0;i < enemy_num;i++) {
        if (p2[i].live) {
            if (abs(p2[i].x - p1.x) < 60 && abs(p2[i].y - p1.y) < 91) {
                TransparentBlt(GetImageHDC(), p1.x, p1.y, 69, 91, GetImageHDC(&img2), 0, 0, 69, 91, transparentColor);
                
                count--;
                for (int i = 0;i < enemy_num;i++) {
                    p2[i].live = 0;
                }
                PlaySound(TEXT("../explosion3.wav"), NULL,
                    SND_FILENAME | SND_ASYNC );
                Sleep(500);
                if (count <= 0) {
                    p1.live = 0;
                    
                }
            }
            if (Buff[i].live) {
                if (abs(p2[i].x+35 - Buff[i].x+8) <= 34 && abs(p2[i].y+45 - Buff[i].y+19) <= 45) {
                    p2[i].live = 0;
                    score += 10;
                    Buff[i].live = 0;
                    PlaySound(TEXT("../explosion3.wav"), NULL,
                        SND_FILENAME | SND_ASYNC);
                    TransparentBlt(GetImageHDC(), p2[i].x, p2[i].x, 69, 91, GetImageHDC(&img2), 0, 0, 69, 91, transparentColor);
                    Sleep(20);
                   
                }
            }

        }
    }
}
void Score() {
    RECT rect = { 0,40,500,110 };
    setbkmode(TRANSPARENT);
    char start[30] = { 0 };
    sprintf(start, "分数：%d", score);
    drawtext(start, &rect, DT_TOP | DT_CENTER);
}
void showGameOver() {
    // 半透明黑色背景
    setfillcolor(BLACK);
    solidrectangle(50, 245, 450, 445);

    // 游戏结束文字
    putimage(50, 245, &gameOverImg);

    // 显示最终分数
    settextcolor(YELLOW);
    settextstyle(28, 0, _T("宋体"));

    char finalScore[50];
    sprintf(finalScore, "最终分数: %d", score);
    outtextxy(150, 400, finalScore);
}
